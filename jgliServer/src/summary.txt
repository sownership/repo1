- 무조건적인 확장성보다는 변할 것과 변하지 않을 것을 잘 결정하는 것이 중요.

- 통신방식, 프로토콜, 요청처리방식, 처리로직들이 서로 의존성이 없도록 설계하여 결합도가 낮음
- systemin, socket 뿐 아니라 새로운 통신방식을 사용하는 서버도 지원하도록 설계
- 다양한 통신방식을 사용하는 클라이언트들을 동일하게 취급할 수 있도록 설계
- 통신방식이 같아도 다양한 프로토콜을 처리할 수 있도록 설계
- 인크립션 뿐 아니라 다른 형태의 요청도 처리할 수 있도록 함

- 파일/통신 입출력은 비동기로 설계하여 thread 자원 활용율을 높임
- 요청 command 에 따라 동적으로 의존성을 주입할 수 있도록 dependancyinjectionutil 을 사용함
  구현은 reflection 과 설정파일을 사용함
- 인크립션은 서로 결합해서 사용할 수 있음 즉, 서브클래싱을 피할 수 있는 구조로 되어 있음.
- 인크립션 방식이 다르다고 controller 가 추가되지 않도록 설계함.
  즉 하나의 controller 가 요청 명령에 따라 다양한 인크립터를 사용할 수 있음
- java nio.2 비동기 통신을 통해 적의수의 thread 로 많은 client 를 처리할 수 있다
- client 가 응답하지 않는 경우 timeout 처리를 하고 구현은 scheduledExecutorService 를 사용한다.
- controller 가 사용할 ThreadPool 은 cpu core 수 만큼만 사용한다.
  file, socket 처리가 모두 비동기이기 때문이다.
- 인크립터는 현재까지 읽은 파일에서 확실한 부분만 처리하고 나머지는 보관한다
- OOM 방지를 위해 파일은 한번에 8k 만큼만 읽는다.
	 * read -> encrypt -> write 가 계속된다
	 * read 는 한번에 8k 이상하는 것은 더 이상의 성능향상이 없다. 오히려 메모리 부담을 줄 수 있다
	 * read 와 write 가 너무 느리므로 encrypt 8k 를 multithread 로 하는 것은 전체 속도에 의미를 못준다
	 * 오히려 read 와 write 를 위한 thread 를 잡아두지 않는 것이 최선이다
	 * 즉 read 와 write 를 비동기로 처리한다
- 제안: 프로토콜 설계의 보완. 예를들어 인크립션방식 등이 client 로부터 전달.

https://www.concretepage.com/java/jdk7/example-seekablebytechannel-java-nio-channels




- 성능과 OOP 원칙을 중요하게 생각하며 설계를 했음.
- 설계 후 직접 개발을 하여 검증을 해 보았습니다.
- 보통 하나의 서버가 c10k problem 이라는 말도 있듯이 10000 개 이상의 client 를 연결해서 서비스하기 어렵습니다.
  비동기로 개발하여 100k client 까지 연결해서 서비스가 잘 되는 것을 확인하였습니다.
  필요시 코드를 제공해 드릴 수 있습니다.
  그리고 client 들과 서버는 초당 2000 tps 까지 통신이 되었습니다.
  파일 핸들링은 동시에 xx 까지 처리가 되는 것을 확인하였습니다.
- NTFS 나 linux 의 recommand block size 는 4KB 이고 효율을 위해 8KB 를 사용한다. 8KB 이하는 8KB 보다 성능이 떨어지고 8KB 이상은 메모리 소비 대비 효율이 높지 않다.
  즉 많은 클라이언트와 파일들을 핸들링하는 시스템이므로 8KB 를 적절한 수준으로 결정했음.
- AsynchronousFileChannel 로 비동기 io 를 하고 싶으나 windows 구현체가 file마다 thread 를 생성하는 문제가 있어서
  seekablefilechannel 과 executorservice 를 이용해서 모든 요청이 공평하게 파일 처리가 되도록 한다.
  이 때 file r/w 와 converter 에는 cpu core 의 1/4~1/2만 할당하여 시스템 전체 성능을 유지해 준다.
- 